diff --git a/Miner/miner/mine_block.py b/Miner/miner/mine_block.py
index 5e099d7..71dfe6c 100644
--- a/Miner/miner/mine_block.py
+++ b/Miner/miner/mine_block.py
@@ -1,64 +1,56 @@
-import os
-from hashlib import sha256
-from merkle_tree import merkleroot
-from PoW import mining
-from create_block_things import create_block_header, create_block
-from tools import decode_transaction, hashdouble
-#from PoW import Block 
-#create merkle tree
-# Test (e.g. block 000000000003ba27aa200b1cecaad478d2b00432346c3f1f3986da1afd33e506)
 
-folder_path = '../../data'  # Replace with your folder path
-file_list = []
-for entry in os.listdir(folder_path):
-    full_path = os.path.join(folder_path, entry)
-    if os.path.isfile(full_path):
-        file_list.append(full_path)  # Use `entry` for filenames only
-raw_transaction = []
-for c in file_list:
-    with open(f'{c}') as f: s = f.read()
-    raw_transaction.append(s)
-# a list of dicts ðŸ¤£
-txs_deserialized = []
-for c in raw_transaction:
-    d = decode_transaction(c)
-    txs_deserialized.append(d)
-#print(txs_deserialized)
 
-txids_list= [] 
-for s in txs_deserialized:
-    version = f"{s["version"]}"# chalenge 
-    inputs = ""
-    for c in s["vin"]:
-        inputs += c
-    outputs = ""
-    for c in s["vout"]:
-        outputs += c
-    locktime = f"{s["vout"]["locktime"]}"
-    txids_list.append(hashdouble((version+inputs+outputs+locktime).encode("utf-8").hex()))
+import hashlib
 
-# TXIDs must be in natural byte order when creating the merkle root
-txids = [''.join([x[i:i+2] for i in range(0, len(x), 2)][::-1]) for x in txids_list]
 
-# Create the merkle root
-result = merkleroot(txids)
-timed = '1231731025'# equivalente a 0x496ab951 : https://www.epochconverter.com/hex?q=496ab951 
-# Display the result in reverse byte order
-merkleroot_final = ''.join([result[i:i+2] for i in range(0, len(result), 2)][::-1])
 
-data_header = {"dificult": "0xae77031e",
-    "version" :  '1',
-    "prev_block" : "00000000000000000006a4a234288a44e715275f1775b77b2fddb6c02eb6b72f",
-    "merkleroot": merkleroot_final,
-    "time" :  timed}
-header,bits= create_block_header(data_header["dificult"], 
-                                data_header["version"],
-                                data_header["prev_block"],
-                                data_header["merkleroot"],
-                                data_header["time"],
-)
-blockhash, nonce = mining(header,0,bits)
-block = create_block(data_header,nonce,bits,raw_transaction)
-print(blockhash)
-#the full block
-print(block)
+#NATIVE INT CAST TO BE
+STATIC_BLOCK_DATA = {
+    "bits" : "ae77031e",
+    "prev_block_hash" : "000000002a22cfee1f2c846adbd12b3e183d4f97683f85dad08a79780a84bd55",
+    "version" : int(1).to_bytes(4, byteorder='little').hex(),
+    "time" : int(1231731025).to_bytes(4, byteorder='little').hex(),
+    "transactions": ["01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0102ffffffff0100f2052a01000000434104d46c4968bde02899d2aa0963367c7a6ce34eec332b32e42e5f3407e052d64ac625da6f0718e7b302140434bd725706957c092db53805b821a85b23a7ac61725bac00000000", "0100000001c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25857fcd3704000000004847304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d0901ffffffff0200ca9a3b00000000434104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302fa28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e6cd84cac00286bee0000000043410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac00000000"]
+}
+
+def reversebytes(data: bytes):
+    bytes_list = [data[i:i+2] for i in range(0, len(data), 2)]
+    reversed_bytes = bytes_list[::-1]
+    str_bytes = []
+    for b in reversed_bytes:
+        str_bytes.append(b.hex())
+    return ''.join(str_bytes)
+
+
+def hash256(item: str):
+    return hashlib.sha256(hashlib.sha256(bytes.fromhex(item)).digest()).digest()
+
+def calculate_merkle_root(transactions: list):
+    return hash256(transactions[0] + transactions[1]).hex()
+
+# from the STATIC_BLOCK_DATA, returns a `partial_header` and `nonce` touple.
+def build_header_template():
+
+    header_list = [STATIC_BLOCK_DATA["version"], STATIC_BLOCK_DATA["prev_block_hash"], calculate_merkle_root(STATIC_BLOCK_DATA["transactions"]), STATIC_BLOCK_DATA["time"], STATIC_BLOCK_DATA["bits"]]
+
+    ret = "".join(header_list)
+
+    return ret, 0
+
+def mine():
+    header, nonce = build_header_template()
+    while True:
+        header = "".join([header , int(nonce).to_bytes(4, byteorder='little').hex()])
+        result = hash256(header)
+        print(result.hex())
+        if int(reversebytes(result), 32) <= int("00000377ae000000000000000000000000000000000000000000000000000000", 32):
+            print("yay, block found")
+            print(f"block hash {reversebytes(result)}")
+            print(f"block_header {header}")
+            break
+        if nonce == 4294967295:
+            print("Block not found on nonce spam")
+            break
+        nonce += 1
+
+mine()
